//
// This file is part of Gambit
// Copyright (c) 1994-2023, The Gambit Project (http://www.gambit-project.org)
//
// FILE: src/tools/enumpoly/monomial.imp
// Implementation of monomial classes
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "monomial.h"


//--------------------------------------------------------------------------
//                 gMono -- constructors and destructor
//--------------------------------------------------------------------------

template<class T> gMono<T>::gMono(const gSpace* p, const T& x) 
: coef(x), exps(p)
{ 
}

template<class T> gMono<T>::gMono(const T& x, const exp_vect& e) 
: coef(x), exps(e)
{ 
  if (x == (T)0) exps.ToZero();
}

template<class T> gMono<T>::gMono(const gMono<T>& y) 
: coef(y.coef), exps(y.exps)
{
}

template<class T> gMono<T>::~gMono() 
= default;

//--------------------------------------------------------------------------
//                             gMono -- operators
//--------------------------------------------------------------------------

template<class T> gMono<T>& gMono<T>::operator = (const gMono<T>& y)
{
  if (this != &y) { coef = y.coef; exps = y.exps; }
  return *this;
}

template<class T> bool gMono<T>::operator == (const gMono<T>& y) const
{
  return (coef == y.coef && exps == y.exps);
}

template<class T> bool gMono<T>::operator != (const gMono<T>& y) const
{
  return !(*this == y);
}

template<class T> gMono<T> gMono<T>::operator * (const gMono<T> & y) const
{
  return gMono<T>(coef * y.coef,exps + y.exps);
}

template<class T> gMono<T> gMono<T>::operator / (const gMono<T>& y) const
{
  //assert ( y.coef != (T)0);
  return gMono<T>(coef / y.coef,exps - y.exps);
}

template<class T> gMono<T> gMono<T>::operator + (const gMono<T> & y) const
{
  //assert (exps == y.exps);
  return gMono<T>(coef + y.coef,exps);
}

template<class T> gMono<T>& gMono<T>::operator += (const gMono<T> & y) 
{
  //assert (exps == y.exps);
  coef += y.coef;
  return *this;
}

template<class T> gMono<T>& gMono<T>::operator *= (const T& val) 
{
  coef *= val;
  return *this;
}

template<class T> gMono<T> gMono<T>::operator - () const
{
  return gMono<T>(-coef,exps);
}

//--------------------------------------------------------------------------
//                             gMono -- information
//--------------------------------------------------------------------------

template<class T> const T &gMono<T>::Coef() const 
{ 
  return coef; 
}

template<class T> int gMono<T>::Dmnsn() const 
{ 
  return exps.Dmnsn(); 
}

template<class T> int gMono<T>::TotalDegree() const 
{ 
  return exps.TotalDegree(); 
}

template<class T> const exp_vect &gMono<T>::ExpV() const 
{ 
  return exps; 
}

template<class T> bool gMono<T>::IsConstant() const 
{ 
  return exps.IsConstant(); 
}

template<class T> bool gMono<T>::IsMultiaffine() const 
{ 
  return exps.IsMultiaffine(); 
}

template<class T> T gMono<T>::Evaluate(const Gambit::Array<T>& vals) const 
{ 
  T answer = Coef();

  for (int i = 1; i <= Dmnsn(); i++)
    for (int j = 1; j <= exps[i]; j++)
      answer *= vals[i];

  return answer;
}

template<class T> T gMono<T>::Evaluate(const Gambit::Vector<T>& vals) const 
{ 
  T answer = Coef();

  for (int i = 1; i <= Dmnsn(); i++)
    for (int j = 1; j <= exps[i]; j++)
      answer *= vals[i];

  return answer;
}


//
// This file is part of Gambit
// Copyright (c) 1994-2013, The Gambit Project (http://www.gambit-project.org)
//
// FILE: src/tools/enumpoly/rectangl.imp
// Implementation of rectangle class
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include <cstdlib>
#include "rectangl.h"
#include "odometer.h"

//--------------------------------------------------------------------------
//                   rectangle -- constructors and destructor
//--------------------------------------------------------------------------

template<class T> gRectangle<T>::gRectangle(const gRectangle<T>& given) 
: sides(given.sides)
{
}

template<class T> gRectangle<T>::gRectangle(const Gambit::List< gInterval<T> >& given)
: sides(given)
{
}

template<class T> gRectangle<T>::gRectangle(const Gambit::Vector<T> lower_bd, 
                                            const Gambit::Vector<T> upper_bd) 
: sides()
{ 
  //assert (lower_bd.Check(upper_bd));
  for (int i = 1; i <= upper_bd.Length(); i++) {
    gInterval<T> side(lower_bd[i],upper_bd[i]);
    sides.Append(side);
  }
}


template<class T> gRectangle<T>::~gRectangle() 
{
}

//--------------------------------------------------------------------------
//                          rectangle -- operators
//--------------------------------------------------------------------------


template<class T> gRectangle<T>& 
gRectangle<T>::operator = (const gRectangle<T>& /* rhs */)
{
  //  gout << "For const'ness, operator = not allowed for gRectangles\n";
  exit (0);
  return *this;
}


template<class T> bool gRectangle<T>::operator == (const gRectangle<T>& rhs)
     const
{
  for (int i = 1; i <= Dmnsn(); i++)
    if (sides[i] != rhs.sides[i]) return false;
  return true;
}

template<class T> bool gRectangle<T>::operator != (const gRectangle<T>& rhs)
     const
{
  return !(*this == rhs);
}

//--------------------------------------------------------------------------
//                             interval -- information
//--------------------------------------------------------------------------

template<class T> const int gRectangle<T>::Dmnsn() const 
{ 
  return sides.Length();
}

template <class T> Gambit::Vector<T> gRectangle<T>::LowerBound(void) const
{ 
  Gambit::Vector<T> answer(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) answer[i] = sides[i].LowerBound();
  return answer;
}

template <class T> Gambit::Vector<T> gRectangle<T>::UpperBound(void) const
{ 
  Gambit::Vector<T> answer(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) answer[i] = sides[i].UpperBound();
  return answer;
}

template<class T> const T gRectangle<T>::LowerBoundOfCoord(const int& i) const 
{ 
  //assert (1 <= i && i <= Dmnsn());
  return sides[i].LowerBound();
}

template<class T> const T gRectangle<T>::UpperBoundOfCoord(const int& i) const 
{ 
  //assert (1 <= i && i <= Dmnsn());
  return sides[i].UpperBound();
}

template<class T> const T gRectangle<T>::HeightInCoord(const int& i) const 
{ 
  //assert (1 <= i && i <= Dmnsn());
  return sides[i].Length();
}

template<class T> 
const gInterval<T> gRectangle<T>::CartesianFactor(const int& i) const 
{ 
  return sides[i];
}

template<class T> 
const gRectangle<T> gRectangle<T>::SameCenterDoubleSideLengths() const 
{ 
  Gambit::List<gInterval<T> > new_sides;
  for (int i = 1; i <= Dmnsn(); i++)
    new_sides.Append(CartesianFactor(i).SameCenterTwiceLength());
  return gRectangle<T>(new_sides);
}

template<class T> 
const gRectangle<T> gRectangle<T>::CubeContainingCrcmscrbngSphere() const 
{ 
  T maxlength((T)0);
  T sumsquares((T)0);
  int i;
  for (i = 1; i <= Dmnsn(); i++) {
    sumsquares += sides[i].Length() * sides[i].Length();
    if (sides[i].Length() > maxlength)
      maxlength = sides[i].Length();
  }
  T diameter((T)0);
  while (diameter * diameter < sumsquares) diameter += maxlength;
  
  Gambit::List<gInterval<T> > new_sides;
  for (i = 1; i <= Dmnsn(); i++)
    new_sides.Append(CartesianFactor(i).SameCenterWithNewLength(diameter));
  return gRectangle<T>(new_sides);
}

template<class T> 
const gRectangle<T> 
gRectangle<T>::Orthant(const Gambit::Array<int>& top_or_bot) const 
{ 
  Gambit::List<gInterval<T> > new_sides;
  for (int i = 1; i <= Dmnsn(); i++)
    if (top_or_bot[i] == 0)
    new_sides.Append(CartesianFactor(i).LeftHalf());
  else
    new_sides.Append(CartesianFactor(i).RightHalf());
  return gRectangle<T>(new_sides);
}

template<class T> const Gambit::Vector<T> gRectangle<T>::SideLengths() const 
{ 
  Gambit::Vector<T> answer(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) 
    answer[i] = sides[i].UpperBound() - sides[i].LowerBound();
  return answer;
}

template<class T> const T gRectangle<T>::MaximalSideLength() const
{
  T answer((T)0);
  for (int i = 1; i <= Dmnsn(); i++)
    if (HeightInCoord(i) > answer) 
      answer = HeightInCoord(i);
  return answer;
}

template<class T> bool gRectangle<T>::Contains(const Gambit::Vector<T>& point) const 
{ 
  //assert (point.Length() == Dmnsn());

  for (int i = 1; i <= Dmnsn(); i++)
    if (point[i] < sides[i].LowerBound() || sides[i].UpperBound() < point[i])
      return false;
  return true;
}

template<class T> bool gRectangle<T>::Contains(const gRectangle<T>& R) const 
{ 
  //assert (R.Dmnsn() == Dmnsn());

  for (int i = 1; i <= Dmnsn(); i++)
    if ( !sides[i].Contains(R.sides[i]) )
      return false;
  return true;
}

template<class T> const T gRectangle<T>::Volume() const 
{ 
  T answer = (T)1;
  for (int i = 1; i <= Dmnsn(); i++)
    answer *= ( sides[i].UpperBound() - sides[i].LowerBound() );
  return answer;
}

template<class T> const Gambit::Vector<T> gRectangle<T>::Center() const 
{ 
  Gambit::Vector<T> answer(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) 
    answer[i] = (sides[i].UpperBound() + sides[i].LowerBound())
		                     / ((T)2);
  return answer;
}

template<class T> const gRectangle<T> gRectangle<T>::BoundingRectangle() const 
{ 
  return *this;
}

template<class T> const Gambit::List<Gambit::Vector<T> > gRectangle<T>::VertexList() const 
{ 
  Gambit::List<Gambit::Vector<T> > answer;

  Gambit::Array<int> ListOfTwos(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) ListOfTwos[i] = 2;
  gIndexOdometer ListOfTopBottoms(ListOfTwos);

  while (ListOfTopBottoms.Turn()) {
    Gambit::Vector<T> next(Dmnsn());
    for (int i = 1; i <= Dmnsn(); i++)
      if (ListOfTopBottoms[i] == 1)
	next[i] = LowerBoundOfCoord(i);
      else 
	next[i] = UpperBoundOfCoord(i);
    answer.Append(next);
  }
  return answer;
}

template<class T> 
const int gRectangle<T>::NumberOfCellsInSubdivision() const 
{ 
  int answer = 1;
  for (int i = 1; i <= Dmnsn(); i++)
    answer *= 2;
  return answer;
}

template<class T> 
const gRectangle<T> gRectangle<T>::SubdivisionCell(const int& index) const 
{ 
  int tmp = index;
  Gambit::Array<int> updowns(Dmnsn());
  for (int i = 1; i <= Dmnsn(); i++) {
    if (tmp % 2 == 1) {
      updowns[i] = 1; tmp--;
    }
    else
      updowns[i] = 0;
  tmp /= 2;
  }
  return Orthant(updowns);
}

template<class T>
const T gRectangle<T>::DiameterSquared() const
{
  T answer((T)0);
  for (int i = 1; i <= Dmnsn(); i++)
    answer += HeightInCoord(i) * HeightInCoord(i);
  return answer;
}

//----------------------------------
//           Conversion
//----------------------------------

template<class T>  
gRectangle<double>  TogDouble(const gRectangle<T>& given) 
{
  Gambit::List<gInterval<double> > cartesian_factors;
  for (int i = 1; i <= given.Dmnsn(); i++) 
    cartesian_factors.Append(gInterval<double>((double)given.LowerBound()[i],
					       (double)given.UpperBound()[i]));
  return gRectangle<double>(cartesian_factors);
}


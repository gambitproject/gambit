//
// This file is part of Gambit
// Copyright (c) 1994-2025, The Gambit Project (https://www.gambit-project.org)
//
// FILE: src/core/matrix.imp
// Implementation of matrix method functions
//
// This program is free software; you can redistribute it and/or modify
// it under the terms of the GNU General Public License as published by
// the Free Software Foundation; either version 2 of the License, or
// (at your option) any later version.
//
// This program is distributed in the hope that it will be useful,
// but WITHOUT ANY WARRANTY; without even the implied warranty of
// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
// GNU General Public License for more details.
//
// You should have received a copy of the GNU General Public License
// along with this program; if not, write to the Free Software
// Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
//

#include "matrix.h"

namespace Gambit {

//-------------------------------------------------------------------------
//       Matrix<T>: Constructors, destructors, constructive operators
//-------------------------------------------------------------------------


template <class T> Matrix<T> &Matrix<T>::operator=(const T &c)
{
  for (int i = MinRow(); i <= MaxRow(); i++) {
    for (int j = MinCol(); j <= MaxCol(); j++) {
      (*this)(i, j) = c;
    }
  }
  return *this;
}

template <class T> Matrix<T> Matrix<T>::operator-()
{
  Matrix<T> tmp(MinRow(), MaxRow(), MinCol(), MaxCol());
  for (int i = MinRow(); i <= MaxRow(); i++) {
    for (int j = MinCol(); j <= MaxCol(); j++) {
      tmp(i, j) = -(*this)(i, j);
    }
  }
  return tmp;
}

//-------------------------------------------------------------------------
//                     Matrix<T>: Additive operators
//-------------------------------------------------------------------------

template <class T> Matrix<T> Matrix<T>::operator+(const Matrix<T> &M) const
{
  if (!this->CheckBounds(M)) {
    throw DimensionException();
  }

  Matrix<T> tmp(MinRow(), MaxRow(), MinCol(), MaxCol());

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      tmp(i, j) = (*this)(i, j) + M(i, j);
    }
  }

  return tmp;
}

template <class T> Matrix<T> Matrix<T>::operator-(const Matrix<T> &M) const
{
  if (!this->CheckBounds(M)) {
    throw DimensionException();
  }

  Matrix<T> tmp(MinRow(), MaxRow(), MinCol(), MaxCol());

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      tmp(i, j) = (*this)(i, j) - M(i, j);
    }
  }

  return tmp;
}

template <class T> Matrix<T> &Matrix<T>::operator+=(const Matrix<T> &M)
{
  if (!this->CheckBounds(M)) {
    throw DimensionException();
  }

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      (*this)(i, j) += M(i, j);
    }
  }

  return *this;
}

template <class T> Matrix<T> &Matrix<T>::operator-=(const Matrix<T> &M)
{
  if (!this->CheckBounds(M)) {
    throw DimensionException();
  }

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      (*this)(i, j) -= M(i, j);
    }
  }

  return *this;
}

//-------------------------------------------------------------------------
//                  Matrix<T>: Multiplicative operators
//-------------------------------------------------------------------------

template <class T> void Matrix<T>::CMultiply(const Vector<T> &in, Vector<T> &out) const
{
  if (!this->CheckRow(in) || !this->CheckColumn(out)) {
    throw DimensionException();
  }

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    T sum = (T)0;

    auto src2 = in.begin();
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      sum += (*this)(i, j) * *(src2++);
    }

    out[i] = sum;
  }
}

template <class T> Matrix<T> Matrix<T>::operator*(const Matrix<T> &M) const
{
  if (MinCol() != M.MinRow() || MaxCol() != M.MaxRow()) {
    throw DimensionException();
  }

  Matrix<T> tmp(MinRow(), MaxRow(), M.MinCol(), M.MaxCol());
  Vector<T> column(M.MinRow(), M.MaxRow());
  Vector<T> result(MinRow(), MaxRow());
  for (int j = M.MinCol(); j <= M.MaxCol(); j++) {
    M.GetColumn(j, column);
    CMultiply(column, result);
    tmp.SetColumn(j, result);
  }
  return tmp;
}

template <class T> Vector<T> Matrix<T>::operator*(const Vector<T> &v) const
{
  if (!this->CheckRow(v)) {
    throw DimensionException();
  }

  Vector<T> tmp(MinRow(), MaxRow());
  CMultiply(v, tmp);
  return tmp;
}

template <class T> void Matrix<T>::RMultiply(const Vector<T> &in, Vector<T> &out) const
{
  if (!this->CheckColumn(in) || !this->CheckRow(out)) {
    throw DimensionException();
  }

  out = (T)0;

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    T k = in[i];
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      out[j] += (*this)(i, j) * k;
    }
  }
}

// transposed (row) vector*matrix multiplication operator
// a friend function of Matrix
template <class T> Vector<T> operator*(const Vector<T> &v, const Matrix<T> &M)
{
  if (!M.CheckColumn(v)) {
    throw DimensionException();
  }
  Vector<T> tmp(M.MinCol(), M.MaxCol());
  M.RMultiply(v, tmp);
  return tmp;
}

template <class T> Matrix<T> Matrix<T>::operator*(const T &s) const
{
  Matrix<T> tmp(MinRow(), MaxRow(), MinCol(), MaxCol());

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      tmp(i, j) = (*this)(i, j) * s;
    }
  }

  return tmp;
}

template <class T> Matrix<T> &Matrix<T>::operator*=(const T &s)
{
  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      (*this)(i, j) *= s;
    }
  }
  return *this;
}

template <class T> Matrix<T> Matrix<T>::operator/(const T &s) const
{
  if (s == (T)0) {
    throw ZeroDivideException();
  }

  Matrix<T> tmp(MinRow(), MaxRow(), MinCol(), MaxCol());

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      tmp(i, j) = (*this)(i, j) / s;
    }
  }

  return tmp;
}

template <class T> Matrix<T> &Matrix<T>::operator/=(const T &s)
{
  if (s == (T)0) {
    throw ZeroDivideException();
  }

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      (*this)(i, j) /= s;
    }
  }

  return *this;
}

//-------------------------------------------------------------------------
//                         Matrix<T>: Transpose
//-------------------------------------------------------------------------

template <class T> Matrix<T> Matrix<T>::Transpose() const
{
  Matrix<T> tmp(MinCol(), MaxCol(), MinRow(), MaxRow());

  for (int i = MinRow(); i <= MaxRow(); i++) {
    for (int j = MinCol(); j <= MaxCol(); j++) {
      tmp(j, i) = (*this)(i, j);
    }
  }

  return tmp;
}

//-------------------------------------------------------------------------
//                    Matrix<T>: Comparison operators
//-------------------------------------------------------------------------

template <class T> bool Matrix<T>::operator==(const Matrix<T> &M) const
{
  if (!this->CheckBounds(M)) {
    throw DimensionException();
  }

  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      if ((*this)(i, j) != M(i, j)) {
        return false;
      }
    }
  }

  return true;
}

template <class T> bool Matrix<T>::operator!=(const Matrix<T> &M) const { return !(*this == M); }

template <class T> bool Matrix<T>::operator==(const T &s) const
{
  for (int i = MinRow(); i <= MaxRow(); ++i) {
    for (int j = MinCol(); j <= MaxCol(); ++j) {
      if ((*this)(i, j) != s) {
        return false;
      }
    }
  }
  return true;
}


template <class T> bool Matrix<T>::operator!=(const T &s) const { return !(*this == s); }

// Information

template <class T> Vector<T> Matrix<T>::Row(int i) const
{
  Vector<T> answer(MinCol(), MaxCol());
  for (int j = MinCol(); j <= MaxCol(); j++) {
    answer[j] = (*this)(i, j);
  }
  return answer;
}

template <class T> Vector<T> Matrix<T>::Column(int j) const
{
  Vector<T> answer(MinRow(), MaxRow());
  for (int i = MinRow(); i <= MaxRow(); i++) {
    answer[i] = (*this)(i, j);
  }
  return answer;
}

// more complex functions

template <class T> void Matrix<T>::MakeIdent()
{
  if (!IsSquare()) {
    throw DimensionException();
  }
  for (int i = MinRow(); i <= MaxRow(); i++) {
    for (int j = MinCol(); j <= MaxCol(); j++) {
      if (i == j) {
        (*this)(i, j) = (T)1;
      }
      else {
        (*this)(i, j) = (T)0;
      }
    }
  }
}

template <class T> void Matrix<T>::Pivot(int row, int col)
{
  if (!this->CheckRow(row) || !this->CheckColumn(col)) {
    throw std::out_of_range("Index out of range in Matrix::Pivot");
  }
  if ((*this)(row, col) == (T)0) {
    throw ZeroDivideException();
  }

  T inv = (T)1 / (*this)(row, col);

  // scale pivot row
  for (int j = MinCol(); j <= MaxCol(); ++j) {
    (*this)(row, j) *= inv;
  }

  // eliminate column
  for (int i = MinRow(); i <= MaxRow(); ++i) {
    if (i != row) {
      T mult = (*this)(i, col);
      for (int j = MinCol(); j <= MaxCol(); ++j) {
        (*this)(i, j) -= (*this)(row, j) * mult;
      }
    }
  }
}

template <class T> Matrix<T> Matrix<T>::Inverse() const
{
  if (!IsSquare()) {
    throw DimensionException();
  }

  Matrix copy(*this);
  Matrix inv(MaxRow(), MaxRow());

  // initialize inverse matrix and prescale row vectors
  for (int i = MinRow(); i <= MaxRow(); i++) {
    T max = (T)0;
    for (int j = MinCol(); j <= MaxCol(); j++) {
      T abs = copy(i, j);
      if (abs < (T)0) {
        abs = -abs;
      }
      if (abs > max) {
        max = abs;
      }
    }

    if (max == (T)0) {
      throw SingularMatrixException();
    }

    T scale = (T)1 / max;
    for (int j = MinCol(); j <= MaxCol(); j++) {
      copy(i, j) *= scale;
      if (i == j) {
        inv(i, j) = scale;
      }
      else {
        inv(i, j) = (T)0;
      }
    }
  }

  for (int i = MinCol(); i <= MaxCol(); i++) {
    // find pivot row
    T max = copy(i, i);
    if (max < (T)0) {
      max = -max;
    }
    int row = i;
    for (int j = i + 1; j <= MaxRow(); j++) {
      T abs = copy(j, i);
      if (abs < (T)0) {
        abs = -abs;
      }
      if (abs > max) {
        max = abs;
        row = j;
      }
    }

    if (max <= (T)0) {
      throw SingularMatrixException();
    }

    copy.SwitchRows(i, row);
    inv.SwitchRows(i, row);
    // scale pivot row
    T factor = (T)1 / copy(i, i);
    for (int k = MinCol(); k <= MaxCol(); k++) {
      copy(i, k) *= factor;
      inv(i, k) *= factor;
    }

    // reduce other rows
    for (int j = MinRow(); j <= MaxRow(); j++) {
      if (j != i) {
        T mult = copy(j, i);
        for (int k = MinCol(); k <= MaxCol(); k++) {
          copy(j, k) -= copy(i, k) * mult;
          inv(j, k) -= inv(i, k) * mult;
        }
      }
    }
  }

  return inv;
}

template <class T> T Matrix<T>::Determinant() const
{
  if (!IsSquare()) {
    throw DimensionException();
  }

  T factor = (T)1;
  Matrix M(*this);

  for (int row = MinRow(); row <= MaxRow(); row++) {

    // Experience (as of 3/22/99) suggests that, in the interest of
    // numerical stability, it might be best to do Gaussian
    // elimination with respect to the row (of those feasible)
    // whose entry has the largest absolute value.
    int swap_row = row;
    for (int i = row + 1; i <= MaxRow(); i++) {
      if (abs(M(i, row)) > abs(M(swap_row, row))) {
        swap_row = i;
      }
    }

    if (swap_row != row) {
      M.SwitchRows(row, swap_row);
      for (int j = MinCol(); j <= MaxCol(); j++) {
        M(row, j) *= (T)-1;
      }
    }

    if (M(row, row) == (T)0) {
      return (T)0;
    }

    // now do row operations to clear the row'th column
    // below the diagonal
    for (int row1 = row + 1; row1 <= MaxRow(); row1++) {
      factor = -M(row1, row) / M(row, row);
      for (int i = MinCol(); i <= MaxCol(); i++) {
        M(row1, i) += M(row, i) * factor;
      }
    }
  }

  // finally we multiply the diagonal elements
  T det = (T)1;
  for (int row = MinRow(); row <= MaxRow(); row++) {
    det *= M(row, row);
  }
  return det;
}

} // end namespace Gambit
